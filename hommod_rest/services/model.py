import logging
import os
import re
import shutil
import sys
import tarfile
import traceback
from gzip import GzipFile
from StringIO import StringIO

from time import time
from suds import client
from urllib import urlopen

from modelutils import (getChainCAsSeqSecStr, getNalignIdentity, downloadPDB,
                        getCoverageIdentity, YasaraChain,
                        identifyDeletedRegions, getPercentageIdentity,
                        filterMinLength, minIdentity,
                        getUniprotSeq, idForSeq, getTemplateSequence)

from interaction import listInteractingChains, InteractionPicker

from filelock import FileLock
from hommod_rest.services.interpro import interpro
from hommod_rest.services.blast import blaster
from hommod_rest.services.align import aligner

import domainalign

_log = logging.getLogger(__name__)

# Record on how long certain modeling steps took,
# for performance monitoring:
def time_log (text):

    logfile = 'time.txt'
    open (logfile, 'a').write (text)

def selectHighestSeqID (seq, fromd):
    qid = 'query'

    bestID = 0
    best = None

    for homolog in fromd.keys():

        # Aligning them all in one run can be very time consuming !
        # So align in pairs

        aligned = aligner.clustalAlign({qid: seq, homolog: fromd[homolog]})
        pid = getPercentageIdentity(aligned[qid], aligned[homolog])

        if pid > bestID:
            bestID = pid
            best = homolog

    return best


# Returns true if a sequence is only X's
def onlyX (seq):
    return (len(seq) == seq.count('X'))


# Many templates contain duplicate chains. This function reduces
# The set of sequences to a smaller set with only unique sequences.
def withoutHomomerDuplicates (chainOrder, chainSequences):

    count = {}
    seq2chains = {}

    # Order chain ids by sequence:
    for chain in chainOrder:
        seq = chainSequences [chain]
        if seq not in count:
            count [seq] = 0
            seq2chains [seq] = []

        count [seq] += 1
        if count [seq] > 1:
            _log.info ("sequence of %s is the same as %s" %\
                       (chain, str (seq2chains [seq])))

        seq2chains [seq].append (chain)

    # Check that every sequence occurs the same number of times:
    sameNum = True
    for n in count.values()[1:]:
        if n != count.values()[0]:
            sameNum = False
            break

    if sameNum: # If all sequences occur twice for example:

        # Return only the first of every set of duplicates:
        newChainSequences = {}
        newChainOrder = []
        for seq in count.keys ():
            newChainSequences [seq2chains [seq][0]] = seq

        for chain in chainOrder:
            if chain in newChainSequences:
                newChainOrder.append (chain)

        return [newChainOrder, newChainSequences]
    else:
        return [chainOrder, chainSequences]


# Parses the alignment from a yasara .ali-file.
def parseAli (filename, tempac):
    targetp = re.compile('\[target(.+)?\]$')

    seqs = {}
    ID = None
    for line in open(filename, 'r').readlines():
        if line.startswith('Sequence:'):

            line = line.strip()
            m = targetp.search(line.strip())
            if m:
                seqs['target'] = line[:m.start()].split(':')[1].strip()
            elif ID.upper().startswith(tempac.upper() + '-'):
                seqs[tempac] = line.split(':')[1].strip()[:len(seqs['target'])]
        else:
            ID = line.split(':')[0].strip()

    return seqs

# Writes the output file that documents where the model's
# sequences come from. This is given per chain.
def writeChainOrigins (description, filename):

    f = open(filename, 'w')
    for chain in description.keys():
        f.write('%s:%s\n' % (chain, description[chain]))
    f.close()

# This output file is no longer generated by the modeling run.
# It gives information per aligned residue to tell how ok the
# alignment is.
def writeDomainMap(filepath, targetAlign, templateAlign, ok):

    f = open (filepath, 'w')
    for i in range (0, len(targetAlign), 100):
        j = min (i + 100, len(targetAlign))
        f.write (targetAlign[i:j] + '\n')
        for n in ok[i:j]:
            if n < 0:
                f.write ('-')
            elif n == 0:
                f.write ('?')
            elif n > 0:
                f.write ('+')
            else:
                f.write (' ')
        f.write ('\n'+templateAlign[i:j]+'\n\n')
    f.close ()

# 'writeAlignmentFasta' creates the input file for YASAYA's modeling run.
# I includes all the chain ids in 'chainOrder' in the alignment.
def writeAlignmentFasta(chainOrder, alignmentsByChain, templateAC, path):
    f = open(path, 'w')

    f.write('>target\n')
    n = 0
    for chain in chainOrder:
        if n > 0:
            f.write('|')
        f.write(alignmentsByChain[chain]['target'])
        n += 1
    f.write('\n')

    f.write('>%s\n' % templateAC)
    n = 0
    for chain in chainOrder:
        if n > 0:
            f.write('|')
        f.write(alignmentsByChain[chain]['template'])
        n += 1
    f.write('\n')

    f.close()

# Modeling requires paths in the configuration settings.
# Therefore, required variables are wrapped in an object.
class Modeler(object):

    # must be set before building models:
    # * yasara dir: where yasara is installed
    # * execution root: where the modeler can run and create temporary files
    # * model root: where finished models should be placed

    def __init__(self, yasara_dir=None):
        self._yasara_dir = yasara_dir
        self.execution_root_dir = None
        self.model_root_dir = None
        self.template_blacklist = None

    @property
    def yasara_dir(self):
        return self._yasara_dir

    @yasara_dir.setter
    def yasara_dir(self, yasara_dir):
        self._yasara_dir = yasara_dir

        if not os.path.isdir(yasara_dir):
            _log.error ("%s not found" % yasara_dir)
            raise ValueError("{} not found".format (yasara_dir))

        # Need to set these path variables before importing the yasara module..
        sys.path.append(os.path.join(yasara_dir, 'pym'))
        sys.path.append(os.path.join(yasara_dir, 'plg'))

        # Don't use graphic mode, it fails without graphical interface!
        import yasaramodule
        self.yasara = yasaramodule
        self.yasara.info.mode = 'txt'

    def _check_init(self):

        from flask import current_app as flask_app

        if not self._yasara_dir:
            self.yasara_dir = flask_app.config ['YASARADIR']

        if not self.execution_root_dir:
            self.execution_root_dir = flask_app.config ['EXECUTIONDIR']

        if not self.model_root_dir:
            self.model_root_dir = flask_app.config ['MODELDIR']

        if not self.template_blacklist:
            self.template_blacklist = flask_app.config ['TEMPLATE_BLACKLIST']

    # The blacklist contains pdb ids of templates that always
    # cause failures in yasara's modeling run.
    # pdbids are added to this blacklist file to exclude them
    # from future blast runs.
    def _add_template_to_blacklist (self, pdbid):

        self._check_init()

        _log.warn ("adding template %s to blacklist %s" %
                   (pdbid.lower (), self.template_blacklist))

        with open (self.template_blacklist, 'a') as f:
            f.write ('%s\n' % pdbid.lower ())

    def _template_in_blacklist (self, pdbid):

        self._check_init()

        with open (self.template_blacklist, 'r') as f:
            pdbids = f.read ().split ()
            return pdbid.lower () in pdbids

    # Use this function to get the template sequences:
    def getChainOrderAndSeqs(self, tempobj):

        _log.info ("indexing protein sequences present in yasara object")

        self._check_init()

        # chainOrder is the order that yasara maintains.

        chainOrder = self.yasara.ListMol('obj %i protein' % tempobj, 'MOL')
        s = self.yasara.SequenceMol('obj %i protein' % tempobj)

        uniqueChainOrder = []
        tempChainSeqs = {}
        for i in range(len(chainOrder)):
            chain = chainOrder[i]
            seq = ''

            for s in self.yasara.SequenceMol(
                    'obj %i mol %s protein' % (tempobj, chain)):
                seq += s

            # Some templates have two protein chains with the same ID:
            if chain not in tempChainSeqs:
                uniqueChainOrder.append (chain)

            tempChainSeqs[chain] = seq

        _log.info ("found %d protein sequences present in yasara object" % len (uniqueChainOrder))

        return [uniqueChainOrder, tempChainSeqs]

    # Get the sequence of one chain in YASARA.
    def getChainSeq(self, tempobj, chain):
        self._check_init()

        return self.yasara.SequenceMol('%s obj %i protein' %
                                       (chain, tempobj))[0]

    # This function loads the template into yasara and also
    # takes some other actions:
    #    * oligomerization (can be switched off)
    #    * symmetry residues: fills in missing residues
    #    * deleting buffer molecules
    #    * replacing residues of type X by alanine or glycine
    #
    # returns the number of the yasara object and the
    # oligomerization factor. (1 if no oligomerization)
    def _set_template(self, tempac, oligomerize=True):

        _log.info ("setting template %s to yasara" % tempac)
        self._check_init()

        self.yasara.Clear()

        pdbfile = os.path.abspath ('%s.pdb' % tempac)
        open (pdbfile, 'w').write (downloadPDB (tempac))
        tempobj = self.yasara.LoadPDB(pdbfile)[0]
        self.yasara.DelObj('not %i' % tempobj)

        # Count the number of molecules in unoligomerized state:
        nMolsUnoligomerized = \
            len(self.yasara.ListMol('obj %i protein' % tempobj, 'MOL'))

        if oligomerize:
            try:
                # Oligomerisation might create extra objects,
                # if so join them together:
                oligolist = self.yasara.OligomerizeObj(tempobj)
                if len(oligolist) > 1:
                    for o in oligolist:
                        if o != tempobj:
                            self.yasara.JoinObj(o, tempobj)

                # oligomerisation = len(oligolist)
            except:
                # oligomerisation might throw an exception,
                # in which case we must restore the old situation
                self.yasara.Clear()
                tempobj = self.yasara.LoadPDB(pdbfile)[0]

            # Count the number of molecules in oligomerized state:
            nMolsOligomerized = len(
                self.yasara.ListMol('obj %i protein' % tempobj, 'MOL'))

            # We want as many chains as possible in the template.
            # If oligomerisation decreased the number of molecules, undo it!
            if nMolsOligomerized < nMolsUnoligomerized:

                self.yasara.Clear()
                tempobj = self.yasara.LoadPDB(pdbfile)[0]

        # If BuildSymRes throws an exception, we just continue
        try:
            self.yasara.BuildSymRes('obj %i' % tempobj)
        except Exception as e:
            _log.warn('Cannot execute BuildSymRes on {}: {}'.format (tempac, e.args [0]))

        # Make sure there's only one chain for each chain identifier:
        chainOrder = self.yasara.ListMol('obj %i protein' % tempobj, 'MOL')
        for i in range (len (chainOrder)):
            if i > 0 and chainOrder [i - 1] == chainOrder [i]:
                _log.debug ("chain %s occurs twice in %s, joining.." %
                            (chainOrder[i], tempac))

                atomnums = self.yasara.ListAtom ('mol %s and obj %i and Protein' %
                                                 (chainOrder[i], tempobj), "ATOMNUM")
                # Call JoinMol on the last molecule in YASARA's order:
                self.yasara.JoinMol ("atom %s" % atomnums [-1])

        # YASARA also cleans when starting a modeling run, but
        # we need to make sure that we have the molecule in its
        # final state, before we start reading from it.
        self.yasara.CleanObj (tempobj)

        # Make sure there are no chains with sequence XXXXXXXXXXXXXXXXXX,
        # Otherwise, yasara would remove the entire chain.
        self.yasara.SwapRes (
            'Protein and UNK and atom CA and atom CB', 'ALA')
        self.yasara.SwapRes (
            'Protein and UNK and atom CA and not atom CB', 'GLY')

        # Delete buffer molecules:
        self.yasara.DelRes ('HOH H2O DOD D2O TIP WAT SOL ACT ACM ACY ' +
                            'EDO EOH FLC FMT GOL I3M IPA MLI MOH PEO ' +
                            'PO4 SO3 SO4 _TE UNX ACE')

        # Final checks for unfixable errors:
        chainOrder = self.yasara.ListMol ('obj %i protein' % tempobj, 'MOL')
        for chain in chainOrder:
            nocc = 0
            for c in chainOrder:
                if c == chain:
                    nocc += 1

            if nocc > 1:
                self._add_template_to_blacklist (tempac)
                _log.error ("chain %s occurs more than once after cleaning" % chain)
                raise Exception ("chain %s occurs more than once after cleaning" % chain)

        _log.info ("initialized yasara template with %d chains" % len (chainOrder))

        return [tempobj, nMolsOligomerized / nMolsUnoligomerized]


    # This function must create the same file types as _build_for_domain,
    # but instead of building a model, use the pdb structure.
    def _collect_template (self, modelDir, mainTargetID, uniprotSpeciesName,
                           mainTemplateID, mainDomainAlignment, mainDomainRange):

        self._check_init()
        _log.info ("collecting template %s for %s, rather than building a model" %\
                   (str (mainTemplateID), mainTargetID))

        pdbac = mainTemplateID.pdbac.lower ()
        chainID = mainTemplateID.chainID
        part = pdbac [1:3]

        pdb_url = 'ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/%s/pdb%s.ent.gz' % (part, pdbac)

        modelPath = os.path.join (modelDir, 'target.pdb')
        alignmentFastaPath = os.path.join (modelDir, 'align.fasta')
        selectedTargetsPath = \
            os.path.join (modelDir, 'selected-targets.txt')

        try:
            # Download and decompress pdb file:
            pdbbuf = StringIO (urlopen (pdb_url).read())
            open (modelPath, 'w').write (GzipFile (fileobj=pdbbuf).read ())

            # Document the match:
            open(selectedTargetsPath, 'w') \
                .write('template: %s\n' % pdbac)

            open (selectedTargetsPath, 'a') \
                .write('\tmatched main target %s with chain %s\n' %
                       (mainTargetID, chainID))

            # Write down the alignment:
            f = open (alignmentFastaPath, 'w')
            f.write ('>target\n')
            f.write (mainDomainAlignment ['target'] + '\n')
            f.write ('>%s_%s\n' % (pdbac, chainID))
            f.write (mainDomainAlignment ['template'] + '\n')
            f.close ()

        except Exception as e:

            # Clean up files of failed operation:
            for path in [modelPath, alignmentFastaPath, selectedTargetsPath]:
                if os.path.isfile (path):
                    os.remove (path)

            raise e

    # This function builds a model for one alignment.
    # It must be given a directory to work in,
    # it also needs the main target's id, sequence and domain range object,
    # a uniprot species id, a template ID (pdbid and chain)
    def _build_for_domain (self, modelDir, mainTargetID, uniprotSpeciesName,
                           mainTemplateID, mainTargetSeq, mainDomainRange):

        self._check_init()
        _log.info ("building model %s range %s on template %s" %
                   (mainTemplateID, str (mainDomainRange), str (mainTemplateID)))

        modelPath = os.path.join(modelDir, 'target.pdb')
        alignmentFastaPath = os.path.join(modelDir, 'align.fasta')
        selectedTargetsPath = \
            os.path.join(modelDir, 'selected-targets.txt')

        open(selectedTargetsPath, 'w') \
            .write('template: %s\n' % mainTemplateID.pdbac)

        # Load template and perform all necessary modifications:
        tempobj, oligomerisation = \
            self._set_template (mainTemplateID.pdbac)

        # One alignment per chain id:
        alignments = {}

        # Get the template's sequences:
        chainOrder, templateChainSequences = \
            self.getChainOrderAndSeqs(tempobj)

        # Remove funny insertions/deletions from main target:
        mainTargetSeq = adjustTargetSequence (mainTargetSeq, templateChainSequences [mainTemplateID.chainID], uniprotSpeciesName)

        _log.debug ("template sequences after _set_template:\n " +
                    str(templateChainSequences))


        # A template can have more than one chain, but the main target is
        # not necessarily homologous to all of these chains. So we must make
        # sure that we find other targets for those other template chains.
        # However, we only need to do this for chains that actually interact
        # with the main target's template chain...

        time_start = time()


        # Part of the main target sequence that's in the domain range:
        mainDomainSeq = \
            mainTargetSeq [mainDomainRange.start: mainDomainRange.end]

        # Add the first alignments,
        # involving the main target sequence:
        # (the main target might be selected for more than one template sequence)
        for chainID in pickTemplateChainsFor (
                templateChainSequences, mainTargetSeq):

            # Of coarse, we've already made an alignment previously
            # while determining the covered domain. However, we want
            # to make a new final alignment here, using a fine-tuned
            # program.

            # It's based on secondary structure, so we get that
            # information first:
            tempCAs, templateChainSeq, templateChainSecStr = \
                getChainCAsSeqSecStr(self.yasara, tempobj, chainID)

            _log.debug ("aligning input target sequence \n{}"
                        .format(mainDomainSeq)
                        + "\nto template {} {}"
                        .format(mainTemplateID.pdbac, chainID)
                        + " sequence\n{}\n{}"
                        .format(templateChainSeq, templateChainSecStr))

            alignments [chainID] = aligner \
                .kmadAlign(templateChainSeq,
                          templateChainSecStr, mainDomainSeq)
            open (selectedTargetsPath, 'a') \
                .write('\tmodeling main target %s on chain %s\n' %
                       (mainTargetID, chainID))

        # Try to find and align target sequences for
        # interacting chains in the template, while keeping
        # in mind which residues interact and must thus be
        # covered by the alignment.
        # We expand the set of involved template
        # chains with every iteration, until all template
        # chains have been added.
        yasaraChains = {}
        for c in self.yasara.ListMol ("obj %i and protein" % tempobj, "MOL"):
            yasaraChains [c] = YasaraChain (self.yasara, tempobj, c)
        while len (alignments) < \
                len (self.yasara.ListMol (
                    'obj %i and protein' % tempobj)):

            # First, make python remember to which
            # chains the candidate chains interact:
            candidateChainInteractsWith = {}
            for c in alignments:
                for chainID in \
                        listInteractingChains (yasaraChains [c]):

                    # Skip those, that we've already aligned
                    # to prevent infinite loops:
                    if chainID in alignments:
                        continue

                    if chainID not in candidateChainInteractsWith:
                        candidateChainInteractsWith[chainID] = []

                    candidateChainInteractsWith [chainID].append(c)

            if len (candidateChainInteractsWith) <= 0:

                # No more interacting chains to add.
                break

            # iterate over chains that might interact with the chains
            # that are already in the set:
            for chainID in candidateChainInteractsWith:

                # Gather the alignments of
                # the interaction partner chains.
                # These are chains that we've already added to the set,
                # so their alignments are already there.
                interactingChainAlignments = {}
                for interactingChainID in \
                        candidateChainInteractsWith[chainID]:

                    interactingChainAlignments [interactingChainID] = \
                        alignments [interactingChainID]

                tempCAs, templateChainSeq, templateChainSecStr = \
                    getChainCAsSeqSecStr (self.yasara, tempobj, chainID)

                # Find targets from the target species, homologous to this template chain:
                potentialTargetSeqs = findTargets (templateChainSeq,
                                                   uniprotSpeciesName)

                _log.debug ("found {} potential target sequences for {} {}"
                           .format (len (potentialTargetSeqs),
                                   mainTemplateID.pdbac, chainID))

                yasaraChain = yasaraChains [chainID]

                # Pick the target with the hightest sequence identity,
                # and domain coverage.
                targetsInterproRanges = {}
                bestPID = 0.0
                selectedTarget = None
                for targetID in potentialTargetSeqs.keys():

                    _log.debug(
                        "aligning potential target sequence\n{}\n"
                        .format(potentialTargetSeqs[targetID])
                        + " to interacting template {} {}"
                        .format(mainTemplateID.pdbac, chainID)
                        + " sequence\n{}\n{}"
                        .format(templateChainSeq, templateChainSecStr))

                    # If we have targets with extremely high coverage,
                    # then we don't need interpro
                    alignment = aligner.kmadAlign(
                        yasaraChain.seq,
                        yasaraChain.secstr,
                        potentialTargetSeqs[targetID])

                    pcov, pid = getCoverageIdentity(
                        alignment['template'], alignment['target'])

                    if pcov > 90.0: # Coverage is large enough, take the whole sequence:

                        if chainID not in alignments or pid > bestPID:
                            alignments[chainID] = alignment
                            bestPID = pid
                            selectedTarget = targetID

                    else: # no luck, bother interpro:
                        targetsInterproRanges [targetID] = interpro \
                            .getInterproDomainLocations (mainTargetSeq)

                if chainID not in alignments: # Not been added yet at this point

                    _log.debug ("no 90 percent coverage target for {} {}"
                               .format(mainTemplateID.pdbac, chainID))

                    # Find out which targets, given their domain ranges,
                    # preserve the interaction with the other chains when
                    # aligned to the template chain:
                    picker = InteractionPicker (chainID,
                        yasaraChains, interactingChainAlignments)
                    alignmentTriplesPerTarget = \
                        domainalign.pickAlignments(
                            yasaraChain, potentialTargetSeqs,
                            targetsInterproRanges, picker)

                    _log.debug("got {} targets passed by domainalign"
                               .format(len(alignmentTriplesPerTarget))
                               + " interacton picker for {} {}"
                               .format(mainTemplateID.pdbac, chainID))

                    # Iterate over targets that passed:
                    for targetID in alignmentTriplesPerTarget:

                        nrange = len(alignmentTriplesPerTarget [targetID])
                        _log.debug("got {} interpro ranges for {} on {} {}"
                                   .format(nrange, targetID,
                                           mainTemplateID.pdbac, chainID))

                        # Join the alignments for this one target into one,
                        # maximizing the coverage of the template chain:
                        domain_alignment = domainalign \
                            .joinAlignmentsToBestTemplateCoverage(
                                alignmentTriplesPerTarget [targetID])

                        # Remove gaps from aligned target sequence:
                        domain_target_seq = \
                            domain_alignment['target'].replace('-', '')

                        _log.debug(
                            "aligning {} domain target sequence\n{}"
                            .format(targetID, domain_target_seq)
                            + "\nto interacting template {} {}"
                            .format(mainTemplateID.pdbac, chainID)
                            + " sequence\n{}\n{}"
                            .format(templateChainSeq, templateChainSecStr))

                        # Realign once more using the complete target
                        # range that we found by joining the alignments:
                        alignment = aligner.kmadAlign(
                            templateChainSeq, templateChainSecStr,
                            domain_target_seq)

                        # Determine the best target for this chain id:
                        # (highest identity)
                        nalign, pid = getNalignIdentity(
                            alignment ['target'], alignment ['template'])
                        if chainID not in alignments or pid > bestPID:
                            alignments [chainID] = alignment
                            bestPID = pid
                            selectedTarget = targetID

                _log.debug("selected target for interacting {} {} is {}"
                           .format (mainTemplateID.pdbac, chainID,
                                   selectedTarget))

                # Occasionally, we don't find any target for a template chain.
                # It's solved here:
                if chainID not in alignments:

                    _log.debug ("putting poly-A on chain {} of {}"
                               .format (chainID, mainTemplateID.pdbac))

                    # Place alanines in the target sequence, with same
                    # length as templare chain:
                    alignments [chainID] = {
                        'template': yasaraChain.seq,
                        'target': 'A' * len(yasaraChain.seq)}
                    selectedTarget = 'poly-A'
                    self.yasara.OccupMol(chainID, 0.0)

                # We document in a file which targets we used for this model:
                open(selectedTargetsPath, 'a') \
                    .write('\tmodeling target %s on chain %s\n'
                           % (selectedTarget, chainID))

        time_targets = time()

        time_log ("took %d seconds to pick targets for template\n" % (time_targets - time_start))

        # < end of interaction finding iter

        # Delete chains that weren't aligned, assuming there's no
        # interaction with the main target's homologs:
        for chainID in chainOrder:
            if chainID not in alignments:

                _log.debug("deleting not-interacting chain {} of {}"
                           .format(chainID, mainTemplateID.pdbac))

                # Only delete protein, keep ligands and nucleic acids, for
                # which no alignments are created.
                self.yasara.DelMol('%s and protein' % chainID)
                open(selectedTargetsPath, 'a') \
                    .write('\tdeleting not-interacting '
                           + 'chain %s from template\n' % chainID)

        # The set of chains might have changed:
        chainOrder, templateChainSequences = \
            self.getChainOrderAndSeqs (tempobj)

        # Make the alignment file for yasara:
        writeAlignmentFasta(
            chainOrder, alignments, mainTemplateID.pdbac,
            alignmentFastaPath)

        # Start the modeling run:
        self.modelWithAlignment(alignmentFastaPath, tempobj)

        if not os.path.isfile ("target.yob"):
            raise Exception ("yasara modeling run did not complete for %s %s (%d - %d)\n%s\n\n"
                             % (uniprotSpeciesName, mainTemplateID,
                                mainDomainRange.start, mainDomainRange.end, mainTargetSeq)
                             + "Please check yasara's output for further details")

        # Save the model in PDB format:
        self.yasara.SavePDB (tempobj, modelPath)

        _log.info ("sucessfully created " + modelPath)

        time_model = time()

        time_log ("yasara modeling run took %d seconds\n" % (time_model - time_targets))


    # This is the main function for building a set of models.
    # Input is a target sequence and a uniprot species id.
    # The function seqrches its own templates.
    #
    # Optional:
    #   requireRes: a residue number in target sequence (1,2,3,..) that must be covered by the model.
    #   overwrite: true if old models must be rebuilt, false if they must be skipped
    def modelProc (self, mainTargetSeq, uniprotSpeciesName, requireRes=None,
                  overwrite=False, chosenTemplateID=None):
        self._check_init()

        _log.info ("building models for %s in %s" % (mainTargetSeq, uniprotSpeciesName))

        if not os.path.isdir(self.model_root_dir):
            os.mkdir(self.model_root_dir)

        if not os.path.isdir(self.execution_root_dir):
            os.mkdir(self.execution_root_dir)

        # A model can have multiple target sequences, since the template
        # can have multiple chains.
        # The target sequence, that the model was built for, will be
        # called the 'main' target sequence.

        # Unique ID for this sequence:
        mainTargetID = idForSeq (mainTargetSeq)

        # Determine all domain ranges within our main target sequence.
        # (source: interpro)
        ranges = interpro.getInterproDomainLocations (mainTargetSeq)

        # yasara sticks to the directory where it was started,
        # so make a unique directory for yasara to run in and
        # let it store all its output files there:
        runDir = os.path.join (self.execution_root_dir,
                               'run-yasara-%s-%s-%i' % (uniprotSpeciesName, mainTargetID, os.getpid ()))
        if os.path.isdir (runDir):
            _log.debug ("removing old verion of %s" % runDir)
            shutil.rmtree (runDir)
        os.mkdir (runDir)
        os.chdir (runDir)

        # Restart yasara, in case if it was already running.
        # We don't want it running in a different directory,
        # could cause errors.
        if self.yasara.pid:

            _log.debug ("restarting yasara for %s %s" % (uniprotSpeciesName, mainTargetSeq))
            self.yasara.Exit ()
            self.yasara.start ()

        time_start = time()

        # Blast and filter alignments that satisfy the given set of
        # domain ranges. No halfway cut domains are alowed!
        if chosenTemplateID:
            tempobj, oligomerisation = \
                self._set_template(chosenTemplateID.pdbac)
            yasaraChain = YasaraChain(self.yasara, tempobj,
                                      chosenTemplateID.chainID)
            mainTargetAlignments = \
                domainalign.getAlignments (ranges, mainTargetSeq, yasaraChain)
        else:
            mainTargetAlignments = \
                domainalign.getAlignments (ranges, mainTargetSeq)

        time_after_alignments = time()

        time_log ("took %i seconds to compute and filter alignments\n" % (time_after_alignments - time_start))

        if len (mainTargetAlignments) <= 0:
            _log.warn ('no alignments found for sequence:\n' + mainTargetSeq)

        _log.info ('got %d alignments for sequence:\n%s' %(len (mainTargetAlignments), mainTargetSeq))

        modelPaths = []
        failedModels = {}

        realign = False

        # Iterate over all alignments that we've got. Any alignment
        # is a potential model.
        for mainDomainRange, mainTemplateID, mainDomainAlignment in \
                mainTargetAlignments:

            # Make sure that we're still in the run directory after the previous iteration:
            os.chdir (runDir)

            # skip ranges that don't cover the requireRes (if given)
            if requireRes and \
                    ((requireRes - 1) < mainDomainRange.start or
                     (requireRes - 1) >= mainDomainRange.end):

                _log.debug ("skipping range %d - %d on %s, bause it does not cover residue %d\n%s\n%s"
                            % (mainDomainRange.start, mainDomainRange.end, mainTemplateID, requireRes,
                               mainDomainAlignment ['target'], mainDomainAlignment ['template']))
                continue

            if chosenTemplateID:
                modelname = '%s_%s_%i-%i_%s' % \
                    (mainTargetID, uniprotSpeciesName,
                     mainDomainRange.start + 1, mainDomainRange.end,
                     str(chosenTemplateID))
            else:
                modelname = '%s_%s_%i-%i' % \
                    (mainTargetID, uniprotSpeciesName,
                     mainDomainRange.start + 1, mainDomainRange.end)

            _log.debug ("locking %s, running from %s" % (modelname, runDir))

            modelDir = os.path.join (self.model_root_dir, modelname)
            modelArchive = modelDir + '.tgz'

            # A unique lockfile name, based on the model name:
            lockfile_path = modelDir + '_lock'

            # we dont want two threads building the same model, so lock:
            lock = FileLock (lockfile_path)

            with lock:
                if os.path.isfile (modelArchive) and not overwrite:

                # Found the archive for this model before starting, see if it's populated:

                    members = tarfile.open (modelArchive, mode='r:gz').getnames()
                    pdbpath = os.path.join (modelname, 'target.pdb')
                    if pdbpath in members:

                        modelPaths.append (modelArchive)

                        _log.info('%s exists, skipping..' % modelArchive)
                        continue

                # the model directory is going to be turned into an archive,
                # All created files will be sent there eventually,
                # but it's not yasara's working directory.
                if not os.path.isdir (modelDir):
                    os.mkdir (modelDir)

                modelPath = os.path.join (modelDir, 'target.pdb')

                if os.path.isfile (modelPath) and not overwrite:
                # Found the output directory for this model already before we started.
                # (just not yet archived)

                    # archive and clean up:
                    os.chdir (self.model_root_dir)
                    tf = tarfile.open (modelname + '.tgz', 'w:gz')
                    tf.add (modelname)  # refers to modelDir
                    tf.close ()
                    shutil.rmtree (modelDir)

                    modelPaths.append (modelArchive)
                    _log.info('%s already exists, skipping..' % modelArchive)
                    continue

                # We're now sure that the model doesn't exist yet.
                # At this point we start the actual model building.
                try:
                    # If the complete template sequence fully matches the target, then
                    # there's no need to build the model.

                    template_seq = getTemplateSequence (mainTemplateID.pdbac, mainTemplateID.chainID)
                    if template_seq == mainDomainAlignment ['template']:

                        _log.debug ("now calling _collect_template for %s %s (%d - %d)\n>target\n%s\n>template\n%s"
                                    % (uniprotSpeciesName, mainTemplateID,
                                       mainDomainRange.start, mainDomainRange.end,
                                       mainDomainAlignment['target'], mainDomainAlignment['template']))

                        self._collect_template (modelDir, mainTargetID,
                                                uniprotSpeciesName, mainTemplateID,
                                                mainDomainAlignment, mainDomainRange)

                    else:
                        _log.debug ("now calling _build_for_domain for %s %s (%d - %d)\n%s"
                                    % (uniprotSpeciesName, mainTemplateID,
                                       mainDomainRange.start, mainDomainRange.end,
                                       mainTargetSeq))

                        self._build_for_domain (modelDir, mainTargetID,
                                                uniprotSpeciesName, mainTemplateID,
                                                mainTargetSeq, mainDomainRange)

                except Exception as ex: # An error ocurred during modeling.

                    # Don't exit, just print error to log and
                    # move on to the next alignment.

                    exc_type, exc_value, exc_traceback = sys.exc_info()
                    stacktrace = ''.join(traceback.format_exception(
                        exc_type, exc_value, exc_traceback))

                    _log.error ('an exception occured for {}:\n{}'
                                .format(modelname, stacktrace))


                    if self._template_in_blacklist (mainTemplateID.pdbac):

                        # The template has just been blacklisted, need to find a new one
                        realign = True
                    else:
                        failedModels [modelname] = stacktrace

                    # Also include error and yasara scene in the model dir,
                    # for debugging and yasara bug reports.
                    open (os.path.join (modelDir, 'errorexit.txt'), 'w') \
                        .write(stacktrace)
                    try:
                        self.yasara.SaveSce (os.path.join (modelDir, 'errorexit.sce'))
                    except:
                        # connection with yasara isn't alive anymore !
                        raise ex

                # At this point the model building has finished.
                # Move files from temporary run directory to their final destination..

                # Move all the files that yasara created:
                for f in os.listdir (runDir):
                    os.rename (os.path.join (runDir, f),
                               os.path.join (modelDir, f))

                # Create archive:
                parent = os.path.dirname (modelDir)
                os.chdir (parent)
                tf = tarfile.open (modelname + '.tgz', 'w:gz')
                tf.add (modelname)  # refers to modelDir
                tf.close ()
                shutil.rmtree (modelDir)
                modelPaths.append (modelArchive)
                os.chdir (runDir)

            # end of this iteration, move over to next range ...

        # Clean up all runtime files:
        _log.debug ("modeling done, cleaning up %s" % runDir)
        os.chdir (self.execution_root_dir)
        shutil.rmtree (runDir)

        _log.info ("finished building all models for %s in %s" %
                   (mainTargetSeq, uniprotSpeciesName))

        if realign:

            # Repeat once more with different templates:
            return self.modelProc (mainTargetSeq, uniprotSpeciesName,
                                   requireRes, overwrite)

        elif len (failedModels) > 0:

            s = ''
            for name in failedModels:
                s += "%s:\n%s\n" % (name, failedModels [name])

            raise Exception ("the following models have failed:\n" + s)
        else:
            return modelPaths


    # This function is called after yasara has finished builing the model.
    # It must perform the final checks to be sure that the model is not too bad.
    # If everything is OK, it must return nothing.
    # If something is wrong, it returns a string telling what's wrong.
    def checkmodel(self, modelobj, templateAC, expectedChains, targetAlignment,
                   templateAlignment):
        self._check_init()

        _log.info ("checking finished model")

        # Check that all chains are there:
        chainOrder, templateChainSequences = self.getChainOrderAndSeqs (modelobj)
        if len (chainOrder) < len (expectedChains):
            return "missing %i chains" % (len (expectedChains) - len (chainOrder))

        # Verify that the alignment is good enough:
        # include one extra iteration to finalize the last chain
        nalign = 0
        nid = 0
        nseq = 1
        # include one extra iteration to finalize the last chain
        for i in range (len (targetAlignment) + 1):

            if i >= len(targetAlignment) or targetAlignment[i] == '|':
                # end of chain

                pid = (100.0 * nid) / nalign
                if pid < min(95, minIdentity(nalign)):
                    return ("sequence %i identity(%.1f)" +
                            " too low for %i residues") % (nseq, pid, nalign)

                nseq += 1
                nalign = 0
                nid = 0
                continue

            else:
                if targetAlignment[i].isalpha() and \
                        templateAlignment[i].isalpha():
                    nalign += 1
                    if targetAlignment[i].upper() == \
                            templateAlignment[i].upper():
                        nid += 1

        # Verify that packing quality didn't decrease to much,
        # relative to template:
        pdbname = 'model%i.pdb' % os.getpid()
        self.yasara.SavePDB(modelobj, pdbname)

        whatifClient = client.Client('http://wiws.cmbi.ru.nl/wsdl',
                                     timeout=60 * 60)

        # Get packing qualities from whatif and determine how much
        # worse the model is than the template:
        modelWhatifID = whatifClient.service.UploadPDB(
            open(pdbname, 'r').read())

        os.remove(pdbname)

        qr = whatifClient.service.PackingQualityMolecule(modelWhatifID)
        if hasattr(qr[0], 'value'):
            modelPackingQuality = qr[0].value
            open('packing.log', 'a') \
                .write('model packing quality is %.3f\n' % modelPackingQuality)
        else:

            _log.warn ("unexpected result from whatif:\n" + str(qr))
            return 'whatif output for model: ' + str(qr)

        qr = whatifClient.service.PackingQualityMolecule(templateAC)
        if hasattr(qr[0], 'value'):
            templatePackingQuality = qr[0].value
            open('packing.log', 'a') \
                .write('template packing quality is %.3f\n' %
                       templatePackingQuality)
        else:
            _log.warn ("unexpected result from whatif:\n" + str(qr))
            return 'whatif output for template: ' + str(qr)

        if modelPackingQuality < (templatePackingQuality - 1.0):

            _log.warn ("Model packing quality %.3f too low" +
                    ", compared to %.3f from template" %
                (modelPackingQuality, templatePackingQuality))

            return ("Model packing quality %.3f too low" +
                    ", compared to %.3f from template" %
                (modelPackingQuality, templatePackingQuality))

    # This function starts the model building process by calling
    # yasara. It will wait for the modeling run to finish.
    def modelWithAlignment (self, alignmentFastaPath, tempobj):

        _log.info ("building a model in yasara from alignment %s" % alignmentFastaPath)
        _log.debug ("running yasara homology modeling experiment from " + os.getcwd())

        if not os.path.isdir (os.getcwd ()):
            raise Exception ("current work dir has been deleted")

        self._check_init()

        self.yasara.Processors(1)

        # self.yasara.Clear()
        self.yasara.ExperimentHomologyModeling(
            templateobj=tempobj,
            alignfile=alignmentFastaPath,
            templates="1, sameseq = 1",
            alignments=1,
            termextension=0,
            oligostate=32,
            looplenmax=10,
            animation='fast',
            speed='fast',
            loopsamples=20,
            resultfile='target'
        )
        self.yasara.Experiment("On")
        self.yasara.Wait("Expend")

        _log.info ("yasara modeling run ended for alignment %s" % alignmentFastaPath)


modeler = Modeler()

# This function iterates through a dictionary of sequences
# and selects the one with most sequence identity to the
# given targetSeq. It returns that one's dictionary key.
def selectMostIdentical(targetSeq, seqs):
    best = None

    naligns = {}
    pids = {}
    for key in seqs.keys():

        d = {key: seqs[key], 'target': targetSeq}
        aligned = aligner.clustalAlign(d)

        nid = 0
        naligns[key] = 0
        for i in range(len(aligned['target'])):
            taa = aligned['target'][i]
            saa = aligned[key][i]

            if taa.isalpha() and saa.isalpha():
                naligns[key] += 1
                if taa.upper() == saa.upper():
                    nid += 1

        pids[key] = nid / naligns[key]

        if not best or pids[key] > pids[best]:
            best = key

    _log.info ("selected most identical sequence:\ntarget:\t%s\n%s:\t%s" % (targetSeq, best, seqs [best]))

    return best

# This function iterates through a dictionary of sequences
# and selects the one with the longest alignment to the
# given targetSeq. It returns that one's dictionary key.
def selectLongestAligned(hits, minLen=0):
    bestHitID = None
    bestHitAlignment = None

    for hitID in hits.keys():
        for alignment in hits[hitID]:
            identity = alignment.getIdentity()
            nalign = alignment.getNumberResiduesAligned()

            if nalign < minLen:
                continue

            if not bestHitID or \
                    nalign > bestHitAlignment.getNumberResiduesAligned() or \
                    nalign == bestHitAlignment.getNumberResiduesAligned() and \
                    identity > bestHitAlignment.getIdentity():
                bestHitID = hitID
                bestHitAlignment = alignment

    return [bestHitID, bestHitAlignment]


# This function finds uniprot isoforms for a given sequence.
# (a sequence that looks almost like it, except for some deletions)
# It makes sure the isoform comes from the given species.
def getIsoforms (seq, uniprotSpeciesName):
    hits = blaster.speciesBlast(seq, uniprotSpeciesName)

    selected = {}
    for hitID in hits:
        for ali in hits[hitID]:
            ac = hitID.split('|')[1]
            if ali.getIdentity() >= 99.0:
                if ac not in selected or \
                        selected[ac].getNumberResiduesAligned() < \
                        ali.getNumberResiduesAligned():
                    selected[ac] = ali

    _log.info ("found %s isofroms %s for\n%s" % (uniprotSpeciesName, str (selected), seq))

    return selected

# This function fills in deletions with pieces from isoforms in uniprot.
# It's necessary sometimes, because deletions might destroy the
# hydrofobic core of a model.
def adjustTargetSequence (targetseq, templateseq, uniprotSpeciesName):

    seqs = {}
    tarkey = 'target'
    seqs[tarkey] = targetseq
    tempkey = 'template'
    seqs[tempkey] = templateseq

    isoformkeys = []
    isoformHits = getIsoforms(targetseq, uniprotSpeciesName)
    for ac in isoformHits.keys():
        hit = isoformHits[ac]
        seqs[ac] = hit.subjectalignment.replace ('-', '').upper()
        if len(seqs[ac]) < 10000:  # avoid titin
            isoformkeys.append(ac)

    aligned = aligner.clustalAlign({
        tempkey: seqs[tempkey], tarkey: seqs[tarkey]})
    deletionRanges = identifyDeletedRegions(aligned[tarkey])

    if len (deletionRanges) <= 0:
        return targetseq

    adjusted = aligned[tarkey]

    # insertions must be added in reverse order, so that indices don't get
    # messed up
    deletionRanges.reverse()
    for i, f in deletionRanges:

        # i:f marks the start and end index in the alignment
        # between template and target

        if len(aligned[tempkey][i:f].replace('-', '')) == 0:

            # Template region is empty too, not a real deletion,
            # no alignment possible
            continue

        # deletionLength = f - i

        tarn = aligned[tarkey][:i].replace('-', '')
        tarc = aligned[tarkey][f:].replace('-', '')

        naligns = {}  # counts residues aligned to the template per isoform
        pids = {}  # % identity to template for each isoform
        best = None  # Best replacement key

        replacement = aligned[tarkey][i:f]  # Initialize as a gap

        for key in isoformkeys:

            # Compare the target sequence to the isoform
            # to see if pieces can be added:

            alignedisoform = \
                aligner.clustalAlign({tarkey: seqs[tarkey], key: seqs[key]})

            # identify the location of the deletion in the isoform
            ai = 0
            while alignedisoform[tarkey][:ai].replace('-', '') != tarn:
                ai += 1

            af = len(alignedisoform[tarkey]) - 1
            while alignedisoform[tarkey][af:].replace('-', '') != tarc:
                af -= 1

            # ai:af marks the start and end index in the alignment
            # between template and isoform

            naligns[key] = 0
            nid = 0
            if len(alignedisoform[key][ai:af].replace('-', '')) > 0:

                # Align to template fragment:
                ali = aligner.clustalAlign({
                    key: alignedisoform[key][ai:af].replace('-', ''),
                    tempkey: aligned[tempkey][i:f].replace('-', '')
                })

                for a in range(len(ali[key])):
                    if ali[key].isalpha() and ali[tempkey].isalpha():
                        naligns[key] += 1
                        if ali[key][a].upper() == ali[tempkey][a].upper():
                            nid += 1

            # Calculate sequence identity to template:
            if naligns[key] > 0:
                pids[key] = (100.0 * nid) / naligns[key]
            else:
                pids[key] = 0.0

            # the more residues filled in, the better
            # second most important is % identity
            if not best or naligns[key] > naligns[best] or \
                    (naligns[key] == naligns[best] and pids[key] > pids[best]):
                best = key
                replacement = alignedisoform[best][ai:af]

        # Fill the deletion with the chosen replacement piece:
        adjusted = adjusted[:i] + replacement + adjusted[f:]

    _log.info ("adjusted\n%s\nto\n%s" % (aligned[tarkey], adjusted))

    return adjusted.replace('-', '')


# For a given sequence, finds an ortholog in the requested species:
# Criteria to be an ortholog: >70% identity and >90% coverage
def findOrthologsToSeq (seq, uniprotSpeciesName):
    orthologs = {}

    hits = blaster.speciesBlast(seq, uniprotSpeciesName)
    for hitID in hits.keys():
        for alignment in hits[hitID]:

            pcov, pid = getCoverageIdentity(
                alignment.queryalignment, alignment.subjectalignment)

            if pid > 70.0:

                ac = hitID.split('|')[1]
                oseq = getUniprotSeq(ac)

                if pcov > 90.0:
                    orthologs[ac] = oseq

    _log.info ("found {} {} orthologs to\n{}"
               .format(len(orthologs), uniprotSpeciesName, seq))

    return orthologs


# The following function is responsible for making the first selection of
# target sequences tht could be modeled on a given template chain sequence.
# The selection will be refined later, based on domain-related criteria.
def findTargets(tempChainSeq, uniprotSpeciesName):
    return findOrthologsToSeq (tempChainSeq, uniprotSpeciesName)


# This function is responsible for grouping sequences that are more than
# 99% identical. The input is a dictionary of sequences and the
# output is a nested list of that dictionary's keys.
def groupIdenticals (d):
    if len(d) <= 1:
        return d.keys()

    alignments = {}

    grouped = []

    ids = d.keys()
    while len(ids) > 0:
        ID = ids[0]
        ids.remove(ID)
        grouped.append([ID])

        for otherID in ids[:]:

            pair = [ID, otherID]
            pair.sort()
            pair = pair[0]+'_'+pair[1]

            # Aligning them all in one run can be very time-consuming

            if pair not in alignments:
                alignments[pair] = aligner.clustalAlign({
                    ID: d[ID],
                    otherID: d[otherID]
                })
            alignedD = alignments[pair]

            if getPercentageIdentity(alignedD[ID], alignedD[otherID]) >= 99.0:
                grouped[-1].append(otherID)
                ids.remove(otherID)

    _log.info ("grouped %d sequences to %d groups" % (len (d), len (grouped)))

    return grouped

# This function is used for choosing which chains of the template
# will be used to model the main target sequence on.
# It's given a main target sequence and all the chains of the template.
# It will return a list with one chain id or more. (in case of duplicates)
def pickTemplateChainsFor (chainSequences, targetSeq):
    identicalChains = groupIdenticals(chainSequences)

    hitChain = selectHighestSeqID (targetSeq,
                                   filterMinLength(30, chainSequences))

    for group in identicalChains:

        if hitChain in group:

            _log.info ("selected chain %s in group %s for\n%s" % (hitChain, len (group), targetSeq))
            return group

    _log.error ('no hit found for %s in template' % targetSeq)
    raise Exception('no hit found for %s in template' % targetSeq)
